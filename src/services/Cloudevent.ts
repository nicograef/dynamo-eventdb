import crypto from 'node:crypto';

import z from 'zod';

/**
 * Based on the [CNCF Cloudevents specification](https://cloudevents.io) version 1.0.2.
 * See https://github.com/cloudevents/spec/blob/v1.0.2/cloudevents/spec.md
 *
 * Example:
 * ```json
 * {
 *   "specversion" : "1.0",
 *   "type" : "com.github.pull_request.opened",
 *   "source" : "https://github.com/cloudevents/spec/pull",
 *   "subject" : "123",
 *   "id" : "A234-1234-1234",
 *   "time" : "2018-04-05T17:31:00Z",
 *   "comexampleextension1" : "value",
 *   "comexampleothervalue" : 5,
 *   "datacontenttype" : "text/xml",
 *   "data" : "<much wow=\"xml\"/>"
 * }
 *  ```
 */
const EventSchema = z.object({
  id: z.string().min(3).describe('Identifies the event. Must be unique within the scope of the producer/source. UUID is recommended.'),
  type: z.string().min(3).describe('The type of event related to the source system and subject. E.g. com.library.book.borrowed:v1'),
  subject: z
    .string()
    .min(3)
    .describe(
      'The subject of the event in the context of the event producer (identified by source). E.g. the entity to which the event is primarily related. E.g. /users/12345',
    ),
  source: z
    .string()
    .min(3)
    .describe(
      'The source of the event. Must be a valid URI-Reference. E.g. https://library.example.com or arn:aws:example:123456789012:event-repo or /cloudevents/spec/pull/123',
    ),
  time: z.date().describe('The timestamp of when the event occurred.'),
  data: z.record(z.string(), z.unknown()).describe('The event payload.'),
});
export type Event = z.infer<typeof EventSchema>;

/**
 * EventCandidate is used when creating a new event, where `id` and `time` are generated by the system.
 */
export type EventCandidate = Omit<Event, 'id' | 'time'>;

/** Database schema for a Cloudevent. */
const DynamoEventSchema = EventSchema.extend({
  time: z.int().min(0),
  time_type: z.string().min(5).includes('_'), // e.g. "1696543200_event"
  pk_all: z.literal('all'),
});
export type DynamoEvent = z.infer<typeof DynamoEventSchema>;

export class Cloudevent {
  public static new(candidate: EventCandidate): { event: Event; error: undefined } | { event: undefined; error: Error } {
    const { error, data } = EventSchema.safeParse({ ...candidate, id: crypto.randomUUID(), time: new Date() });
    if (error) return { event: undefined, error: new Error(error.message) };
    return { event: data, error: undefined };
  }

  public static fromDynamo(dynamoEvent: DynamoEvent): { event: Event; error: undefined } | { event: undefined; error: Error } {
    const { error: dynamoError, data: dynamoData } = DynamoEventSchema.safeParse(dynamoEvent);
    if (dynamoError) return { event: undefined, error: new Error(dynamoError.message) };

    const { error, data } = EventSchema.safeParse({ ...dynamoData, time: new Date(dynamoData.time) });
    if (error) return { event: undefined, error: new Error(error.message) };

    return { event: data, error: undefined };
  }

  public static toDynamo(event: Event): { dynamoEvent: DynamoEvent; error: undefined } | { dynamoEvent: undefined; error: Error } {
    const { error, data } = DynamoEventSchema.safeParse({
      ...event,
      time: event.time.getTime(),
      time_type: `${event.time.getTime()}_${event.type}`,
      pk_all: 'all',
    });
    if (error) return { dynamoEvent: undefined, error: new Error(error.message) };
    return { dynamoEvent: data, error: undefined };
  }
}
